{"ast":null,"code":"import { jsxs as _jsxs } from \"react/jsx-runtime\";\nimport { Fragment as _Fragment } from \"react/jsx-runtime\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// Third-party imports\nimport React, { useState, useCallback } from 'react';\nimport { FormControl, FormHelperText, TextField, CircularProgress, makeStyles } from '@material-ui/core';\nimport { Controller } from 'react-hook-form';\nimport Autocomplete from '@material-ui/lab/Autocomplete'; // App imports\n\nconst useStyles = makeStyles(theme => ({\n  selectInput: {\n    '& .MuiInputBase-root': {\n      border: '1px solid #565656',\n      borderRadius: '6px',\n      paddingLeft: '10px',\n      marginTop: '15px',\n      '& .MuiInputBase-input': {\n        border: 'none'\n      }\n    },\n    '& >.MuiInput-underline:after': {\n      border: 'none'\n    },\n    '& .MuiAutocomplete-endAdornment': {\n      top: '0'\n    }\n  }\n})); // Component\n\nexport default function FormBuilderAutocomplete({\n  field,\n  error,\n  form\n}) {\n  var _form$getValues$field, _field$rules;\n\n  const {\n    0: query,\n    1: setQuery\n  } = useState('');\n  const {\n    0: open,\n    1: setOpen\n  } = useState(false);\n  const {\n    0: loading,\n    1: setLoading\n  } = useState(false);\n  const classes = useStyles();\n  const {\n    0: options,\n    1: setOptions\n  } = useState(Array.isArray(field.options) ? field.options : []);\n  const optionsFunction = Array.isArray(field.options) ? null : field.options;\n  const {\n    0: inputText,\n    1: setInputText\n  } = useState(((_form$getValues$field = form.getValues()[field.name]) === null || _form$getValues$field === void 0 ? void 0 : _form$getValues$field.label) || '');\n  const {\n    0: currentValue,\n    1: setCurrentValue\n  } = useState(form.getValues()[field.name]);\n  const updateOptions = useCallback(() => {\n    if (optionsFunction) {\n      setLoading(true);\n      optionsFunction(form, query).then(newOptions => {\n        setOptions(newOptions || []); // This fixes the bug in Autocomplete, that does not refresh the label\n        // const currentValue = form.getValues()[field.name];\n\n        if (currentValue) {\n          console.log({\n            currentValue,\n            inputText\n          });\n\n          if (field.multiple) {\n            form.setValue(field.name, field.multiple ? [] : null);\n          } else {\n            form.setValue(field.name, currentValue);\n          }\n        }\n      }).finally(() => setLoading(false));\n    }\n  }, [optionsFunction, form, query, field.multiple, field.name]); // If it has a value, an the option in not loaded, then load options\n\n  let shouldLoad; // const currentValue = form.getValues()[field.name];\n\n  if (field.multiple) {\n    shouldLoad = optionsFunction && currentValue && currentValue.length && !options.filter(o => currentValue.indexOf(o.value) >= 0).length;\n  } else {\n    shouldLoad = optionsFunction && currentValue && !options.find(o => o.value === currentValue);\n  }\n\n  const {\n    0: mounted,\n    1: setMounted\n  } = useState(false); // Load option it is has data\n\n  React.useEffect(() => {\n    // let mounted = true;\n    if (!mounted && shouldLoad) {\n      updateOptions();\n      setMounted(true);\n      setCurrentValue(form.getValues()[field.name]);\n    }\n  }, [shouldLoad, updateOptions]); // Load option it is has data\n\n  React.useEffect(() => {\n    let fieldVal = '';\n\n    if (typeof form.getValues()[field.name] === 'object') {\n      var _form$getValues$field2;\n\n      fieldVal = (_form$getValues$field2 = form.getValues()[field.name]) === null || _form$getValues$field2 === void 0 ? void 0 : _form$getValues$field2.label;\n    } else if (typeof form.getValues()[field.name] === 'string') {\n      fieldVal = form.getValues()[field.name];\n    } else {\n      fieldVal = '';\n    } // setCurrentValue(form.getValues()[field.name]);\n\n\n    setInputText(fieldVal); // console.log({field: field.name, fieldVal, currentValue, inputText})\n  }, [field, form, setCurrentValue]);\n\n  const getInputTextValue = props => {\n    var _props$value;\n\n    return ((_props$value = props.value) === null || _props$value === void 0 ? void 0 : _props$value.label) || inputText || '';\n  };\n\n  return /*#__PURE__*/_jsxs(FormControl, {\n    component: \"fieldset\",\n    error: !!error,\n    fullWidth: true,\n    children: [/*#__PURE__*/_jsx(Controller, {\n      label: field.label + (((_field$rules = field.rules) === null || _field$rules === void 0 ? void 0 : _field$rules.required) === true ? ' *' : ''),\n      defaultValue: currentValue,\n      render: props => /*#__PURE__*/_jsx(Autocomplete, {\n        freeSolo: true,\n        open: open,\n        onOpen: () => {\n          setOpen(true);\n          updateOptions();\n        },\n        onClose: () => setOpen(false),\n        options: options,\n        disabled: field.disabled,\n        loading: loading,\n        multiple: field.multiple,\n        getOptionDisabled: () => loading,\n        getOptionSelected: (option, value) => option.value === (!value ? '' : typeof value === 'string' ? value : value === null || value === void 0 ? void 0 : value.value),\n        onChange: (event, newValue) => {\n          var _options$find;\n\n          const aux = newValue === null ? '' : newValue;\n          form.setValue(field.name, typeof newValue === 'string' ? aux : aux === null || aux === void 0 ? void 0 : aux.value);\n          setInputText(((_options$find = options.find(o => o.value === (typeof newValue === 'string' ? aux : newValue === null || newValue === void 0 ? void 0 : newValue.value))) === null || _options$find === void 0 ? void 0 : _options$find.label) || '');\n          setCurrentValue(newValue); // setInputText(aux.label ? aux?.label : aux);\n\n          setQuery(aux.label ? aux === null || aux === void 0 ? void 0 : aux.label : aux);\n          field.onChange && field.onChange(aux, form);\n        },\n        getOptionLabel: option => {\n          var _options$find2;\n\n          return ((_options$find2 = options.find(o => o.value === (typeof option === 'string' ? option : option.value))) === null || _options$find2 === void 0 ? void 0 : _options$find2.label) || '';\n        },\n        value: props.value,\n        inputValue: getInputTextValue(props),\n        renderInput: params => /*#__PURE__*/_jsx(TextField, _objectSpread(_objectSpread({}, params), {}, {\n          // value={props.value}\n          error: !!error,\n          label: field.label,\n          className: classes.selectInput,\n          fullWidth: true,\n          placeholder: field.placeholder,\n          onChange: event => {\n            setInputText(event.target.value);\n\n            if (field.onUpdate) {\n              field.onUpdate(event.target.value, form);\n            }\n\n            setQuery(event.target.value);\n            updateOptions();\n          },\n          InputProps: _objectSpread(_objectSpread({}, params.InputProps), {}, {\n            endAdornment: /*#__PURE__*/_jsxs(_Fragment, {\n              children: [loading ? /*#__PURE__*/_jsx(CircularProgress, {\n                color: \"inherit\",\n                size: 20\n              }) : null, params.InputProps.endAdornment]\n            })\n          })\n        }))\n      }),\n      id: field.name,\n      name: field.name,\n      rules: field.rules,\n      noOptionsText: field.noOptionsText ? field.noOptionsText : 'No hay opciones',\n      control: form.control,\n      onChange: args => {\n        var _field$onChange;\n\n        const value = !args[1] ? null : field.multiple ? args[1].map(v => v.value || v) : args[1].value;\n        (_field$onChange = field.onChange) === null || _field$onChange === void 0 ? void 0 : _field$onChange.call(field, value, form);\n        return value;\n      }\n    }), error && /*#__PURE__*/_jsx(FormHelperText, {\n      className: 'Mui-error',\n      children: error\n    })]\n  });\n}","map":null,"metadata":{},"sourceType":"module"}