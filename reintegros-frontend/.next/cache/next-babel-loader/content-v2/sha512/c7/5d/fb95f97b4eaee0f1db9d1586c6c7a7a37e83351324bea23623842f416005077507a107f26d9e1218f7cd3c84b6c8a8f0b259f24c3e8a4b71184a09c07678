{"ast":null,"code":"import { Fragment as _Fragment } from \"react/jsx-runtime\";\nimport { jsxs as _jsxs } from \"react/jsx-runtime\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { TextField, Checkbox, RadioGroup, FormControl, FormControlLabel, Radio, FormHelperText, FormLabel, InputLabel, Select, MenuItem, InputAdornment } from '@material-ui/core';\nimport { KeyboardDatePicker, KeyboardTimePicker, MuiPickersUtilsProvider } from '@material-ui/pickers';\nimport React from 'react';\nimport { Controller } from 'react-hook-form';\nimport { FieldType } from './FormField';\nimport DateFnsUtils from '@date-io/date-fns';\nimport { format, parseISO } from 'date-fns';\nimport { FORM_BUILDER } from '../../labels';\nimport FieldAutocomplete from './FieldAutocomplete';\nimport FileInput from '../common/FileInput'; // Needed for prevent passing 'value' and 'onChange' props\n\nconst DatePicker = KeyboardDatePicker;\nconst TimePicker = KeyboardTimePicker;\nexport const getError = (field, errors) => {\n  var _field$rules, _field$rules2, _field$rules3, _field$rules4;\n\n  if (errors && errors[field.name]) {\n    switch (errors[field.name].type) {\n      case 'required':\n        return FORM_BUILDER.required;\n\n      case 'min':\n        return `${FORM_BUILDER.min} ${(_field$rules = field.rules) === null || _field$rules === void 0 ? void 0 : _field$rules.min}`;\n\n      case 'minLength':\n        return `${FORM_BUILDER.minLength} ${(_field$rules2 = field.rules) === null || _field$rules2 === void 0 ? void 0 : _field$rules2.minLength}`;\n\n      case 'max':\n        return `${FORM_BUILDER.max} ${(_field$rules3 = field.rules) === null || _field$rules3 === void 0 ? void 0 : _field$rules3.max}`;\n\n      case 'maxLength':\n        return `${FORM_BUILDER.maxLength} ${(_field$rules4 = field.rules) === null || _field$rules4 === void 0 ? void 0 : _field$rules4.maxLength}`;\n\n      case 'pattern':\n        return errors[field.name].message || FORM_BUILDER.pattern;\n\n      case 'validate':\n        return errors[field.name].message;\n\n      default:\n        return FORM_BUILDER.default;\n    }\n  } else {\n    return null;\n  }\n};\nexport const getRules = (field, form) => {\n  const rules = field.rules || {};\n\n  if (rules.validate) {\n    const oldMethod = rules.validate;\n\n    rules.validate = () => oldMethod(form);\n  }\n\n  return rules;\n};\nexport default function FieldRender({\n  field,\n  form,\n  data\n}) {\n  var _ref, _ref2, _ref3, _ref5, _ref6, _ref7;\n\n  const {\n    control,\n    errors\n  } = form;\n  const variant = 'standard';\n  const error = getError(field, errors);\n  const rules = getRules(field, form);\n\n  if (field.component === 'email') {\n    rules.pattern = /^[a-zA-Z0-9.!#$%&â€™*+/=?^_`{|}~-]+@[a-zA-Z0-9-]+(?:\\.[a-zA-Z0-9-]+)*$/;\n  } // Prefix & Suffix\n\n\n  const inputProps = {};\n\n  if (field.prefix) {\n    inputProps.startAdornment = /*#__PURE__*/_jsx(InputAdornment, {\n      position: \"start\",\n      children: field.prefix\n    });\n  }\n\n  if (field.suffix) {\n    inputProps.endAdornment = /*#__PURE__*/_jsx(InputAdornment, {\n      position: \"end\",\n      children: field.suffix\n    });\n  }\n\n  switch (field.type) {\n    case FieldType.date:\n      return /*#__PURE__*/_jsx(MuiPickersUtilsProvider, {\n        utils: DateFnsUtils,\n        children: /*#__PURE__*/_jsx(Controller, {\n          variant: variant,\n          name: field.name,\n          label: field.label,\n          control: control,\n          error: !!error,\n          rules: rules,\n          defaultValue: (_ref = data[field.name] && format(parseISO(data[field.name]), 'dd/MM/yyyy')) !== null && _ref !== void 0 ? _ref : new Date(),\n          render: props => /*#__PURE__*/_jsx(DatePicker, {\n            value: props.value,\n            onChange: props.onChange,\n            inputRef: props.ref,\n            autoOk: true,\n            disableToolbar: true,\n            variant: \"inline\",\n            format: \"dd/MM/yyyy\",\n            inputVariant: variant,\n            fullWidth: true,\n            label: field.label,\n            helperText: error,\n            disabled: field.disabled,\n            KeyboardButtonProps: {\n              'aria-label': 'change date'\n            }\n          })\n        })\n      });\n      break;\n\n    case FieldType.time:\n      return /*#__PURE__*/_jsx(MuiPickersUtilsProvider, {\n        utils: DateFnsUtils,\n        children: /*#__PURE__*/_jsx(Controller, {\n          variant: variant,\n          error: !!error,\n          rules: rules,\n          render: props => /*#__PURE__*/_jsx(TimePicker, {\n            value: props.value,\n            onChange: props.onChange,\n            inputRef: props.ref,\n            autoOk: true,\n            variant: \"inline\",\n            disableToolbar: true,\n            inputVariant: variant,\n            fullWidth: true,\n            label: field.label,\n            error: !!error,\n            helperText: error,\n            disabled: field.disabled,\n            format: \"HH:mm\",\n            KeyboardButtonProps: {\n              'aria-label': 'change time'\n            }\n          }),\n          name: field.name,\n          placeholder: field.placeholder,\n          control: control\n        })\n      });\n      break;\n\n    case FieldType.int:\n      return /*#__PURE__*/_jsx(Controller, {\n        render: props => {\n          var _parseInt;\n\n          return /*#__PURE__*/_jsx(TextField, {\n            label: field.label,\n            value: (_parseInt = parseInt(props.value)) !== null && _parseInt !== void 0 ? _parseInt : 0,\n            name: field.name,\n            variant: variant,\n            fullWidth: true,\n            type: \"number\",\n            helperText: error,\n            inputRef: props.ref,\n            onChange: event => {\n              form.setValue(field.name, parseInt(event.target.value));\n              field.onChange && field.onChange(parseInt(event.target.value), form);\n            },\n            InputProps: inputProps\n          });\n        },\n        defaultValue: (_ref2 = data && data[field.name]) !== null && _ref2 !== void 0 ? _ref2 : 0,\n        type: \"number\",\n        name: field.name,\n        label: field.label,\n        control: control,\n        error: !!error,\n        rules: rules\n      });\n\n    case FieldType.float:\n      return /*#__PURE__*/_jsx(Controller, {\n        render: props => /*#__PURE__*/_jsx(TextField, {\n          label: field.label,\n          value: props.value,\n          name: field.name,\n          type: \"number\",\n          variant: variant,\n          fullWidth: true,\n          helperText: error,\n          inputRef: props.ref,\n          onChange: e => props.onChange(e.target.value)\n        }),\n        defaultValue: (_ref3 = data && data[field.name]) !== null && _ref3 !== void 0 ? _ref3 : 0,\n        name: field.name,\n        label: field.label,\n        control: control,\n        error: !!error,\n        rules: rules\n      });\n      break;\n\n    case FieldType.options:\n      if (!Array.isArray(field.options)) {\n        return /*#__PURE__*/_jsx(FieldAutocomplete, {\n          field: field,\n          error: error,\n          rules: rules,\n          form: form\n        });\n      } else {\n        var _ref4;\n\n        return /*#__PURE__*/_jsxs(FormControl, {\n          variant: variant,\n          fullWidth: true,\n          children: [/*#__PURE__*/_jsx(InputLabel, {\n            children: field.label\n          }), /*#__PURE__*/_jsx(Controller, {\n            control: control,\n            name: field.name,\n            id: field.name,\n            error: !!error,\n            disabled: field.disabled,\n            rules: rules,\n            defaultValue: (_ref4 = data && data[field.name]) !== null && _ref4 !== void 0 ? _ref4 : '',\n            render: props => /*#__PURE__*/_jsx(Select, {\n              label: field.label,\n              value: props.value,\n              onChange: e => {\n                var _e$target$value, _e$target;\n\n                return props.onChange((_e$target$value = e === null || e === void 0 ? void 0 : (_e$target = e.target) === null || _e$target === void 0 ? void 0 : _e$target.value) !== null && _e$target$value !== void 0 ? _e$target$value : null);\n              },\n              disabled: field.disabled,\n              children: field.options.map((elem, index) => /*#__PURE__*/_jsx(MenuItem, {\n                value: elem.value,\n                children: elem.label\n              }, index))\n            })\n          }), error && /*#__PURE__*/_jsx(FormHelperText, {\n            children: error\n          })]\n        });\n      }\n\n      break;\n\n    case FieldType.boolean:\n      return /*#__PURE__*/_jsx(FormControlLabel, {\n        control: /*#__PURE__*/_jsx(Controller, {\n          error: !!error,\n          rules: rules,\n          helperText: error,\n          variant: variant,\n          fullWidth: true,\n          label: field.label,\n          render: props => /*#__PURE__*/_jsx(Checkbox, {\n            onChange: event => {\n              form.setValue(field.name, event.target.checked);\n              field.onChange(event.target.checked, form);\n            }\n          }),\n          valueName: \"checked\",\n          name: field.name,\n          control: control,\n          color: \"primary\",\n          disabled: field.disabled,\n          defaultValue: data[field.name] || false\n        }),\n        label: field.label\n      });\n      break;\n\n    case FieldType.radio:\n      return /*#__PURE__*/_jsx(FormControlLabel, {\n        label: '',\n        control: /*#__PURE__*/_jsx(Controller, {\n          error: !!error,\n          rules: rules,\n          helperText: error,\n          variant: variant,\n          fullWidth: true,\n          label: field.label,\n          render: props => {\n            var _field$options;\n\n            return /*#__PURE__*/_jsxs(RadioGroup, {\n              name: field.name,\n              onChange: event => {\n                form.setValue(field.name, event.target.value);\n                field.onChange(event.target.value, form);\n              },\n              value: props.value,\n              children: [/*#__PURE__*/_jsx(FormLabel, {\n                component: \"legend\",\n                children: field.label\n              }), (_field$options = field.options) === null || _field$options === void 0 ? void 0 : _field$options.map((opt, i) => {\n                return /*#__PURE__*/_jsx(FormControlLabel, {\n                  value: opt.value,\n                  control: /*#__PURE__*/_jsx(Radio, {}),\n                  label: opt.label\n                }, i); // return <Radio value={opt.value} key={i} label={}/> + ' ' + opt.label;\n              })]\n            });\n          },\n          valueName: \"checked\",\n          name: field.name,\n          control: control,\n          color: \"primary\",\n          disabled: field.disabled,\n          defaultValue: data[field.name] || false\n        })\n      });\n      break;\n\n    case FieldType.file:\n      return /*#__PURE__*/_jsx(Controller, {\n        render: props => /*#__PURE__*/_jsx(FileInput, _objectSpread(_objectSpread({}, props), {}, {\n          accept: field.accept || '',\n          multiple: field.multiple\n        })),\n        defaultValue: (_ref5 = data && data[field.name]) !== null && _ref5 !== void 0 ? _ref5 : null,\n        name: field.name,\n        label: field.label,\n        control: control,\n        error: !!error,\n        rules: rules\n      });\n      break;\n\n    default:\n      return /*#__PURE__*/_jsx(Controller, {\n        render: props => /*#__PURE__*/_jsx(_Fragment, {\n          children: /*#__PURE__*/_jsx(FormControl, {\n            variant: variant,\n            fullWidth: true,\n            children: /*#__PURE__*/_jsx(TextField, {\n              label: field.label,\n              name: field.name,\n              id: field.name,\n              variant: variant,\n              fullWidth: true,\n              helperText: error,\n              inputRef: props.ref,\n              onChange: e => {\n                props.onChange(e.target.value);\n                field.onChange && field.onChange(e.target.value, form);\n              },\n              disabled: field.disabled // value={(data && data[field.name]) ?? ''}\n              ,\n              value: props.value,\n              InputProps: inputProps\n            })\n          })\n        }),\n        value: (_ref6 = data && data[field.name]) !== null && _ref6 !== void 0 ? _ref6 : '',\n        defaultValue: (_ref7 = data && data[field.name]) !== null && _ref7 !== void 0 ? _ref7 : '',\n        name: field.name,\n        label: field.label,\n        control: control,\n        error: !!error,\n        rules: rules\n      });\n      break;\n  }\n}","map":null,"metadata":{},"sourceType":"module"}