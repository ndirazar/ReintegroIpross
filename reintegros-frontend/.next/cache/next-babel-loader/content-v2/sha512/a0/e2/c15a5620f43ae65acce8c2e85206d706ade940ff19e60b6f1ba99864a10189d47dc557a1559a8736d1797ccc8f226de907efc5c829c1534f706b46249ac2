{"ast":null,"code":"import axios from 'axios';\nimport Cookies from 'universal-cookie';\naxios.defaults.baseURL = process.env.NEXT_PUBLIC_API;\nconst client = axios.create({\n  baseURL: process.env.NEXT_PUBLIC_API\n}); //Send token in all requests\n\nclient.interceptors.request.use(async config => {\n  const cookies = new Cookies();\n  const access = cookies.get('access');\n\n  if (access) {\n    config.headers = {\n      Authorization: `Bearer ${access}`\n    };\n  }\n\n  return config;\n}, error => {\n  Promise.reject(error);\n}); //Refresh token and retry on 401 error\n\nclient.interceptors.response.use(response => response, async function (error) {\n  var _error$response;\n\n  const cookies = new Cookies();\n  const originalRequest = error.config;\n  const refresh = cookies.get('refresh'); //If token is expired and exist refresh is saved on cookies i can try renew access\n\n  if (((_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status) === 401 && !originalRequest._retry && refresh) {\n    originalRequest._retry = true;\n    const res = await axios.post('api/token/refresh/', {\n      refresh\n    });\n    const {\n      access\n    } = res.data;\n\n    if (access) {\n      cookies.set('access', access, {\n        path: '/'\n      });\n    } else {\n      //Refresh is invalid. TODO redirect login\n      cookies.remove('access');\n      cookies.remove('refresh');\n    }\n\n    return client(originalRequest);\n  }\n\n  return Promise.reject(error);\n});\n\nconst handleError = async error => {\n  return Promise.reject(error);\n};\n\nconst handleSuccess = response => {\n  return response;\n};\n\nconst request = async options => {\n  return client(options).then(handleSuccess).catch(handleError);\n};\n\nconst post = async (url, data) => {\n  return request({\n    url: `${url}/`,\n    data,\n    method: 'POST'\n  });\n};\n\nconst get = async url => {\n  return request({\n    url,\n    method: 'GET'\n  });\n};\n\nconst remove = async (url, id) => {\n  return request({\n    url: `${url}/${id}/`,\n    method: 'DELETE'\n  });\n};\n\nconst put = async (url, data, id) => {\n  return request({\n    url: `${url}/${id}/`,\n    data,\n    method: 'PUT'\n  });\n};\n\nconst patch = async (url, data, id) => {\n  return request({\n    url: `${url}/${id}/`,\n    data,\n    method: 'PATCH'\n  });\n};\n\nexport { post, request as send, client, get, put, remove, patch };","map":{"version":3,"sources":["/reintegros/reintegros-frontend/components/api-call/service.ts"],"names":["axios","Cookies","defaults","baseURL","process","env","NEXT_PUBLIC_API","client","create","interceptors","request","use","config","cookies","access","get","headers","Authorization","error","Promise","reject","response","originalRequest","refresh","status","_retry","res","post","data","set","path","remove","handleError","handleSuccess","options","then","catch","url","method","id","put","patch","send"],"mappings":"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","sourcesContent":["import { IResponse } from './types';\nimport axios from 'axios';\nimport Cookies from 'universal-cookie';\n\naxios.defaults.baseURL = process.env.NEXT_PUBLIC_API;\nconst client = axios.create({ baseURL: process.env.NEXT_PUBLIC_API });\n//Send token in all requests\n\nclient.interceptors.request.use(\n  async (config) => {\n    const cookies = new Cookies();\n    const access = cookies.get('access');\n\n    if (access) {\n      config.headers = {\n        Authorization: `Bearer ${access}`,\n      };\n    }\n\n    return config;\n  },\n  (error) => {\n    Promise.reject(error);\n  },\n);\n//Refresh token and retry on 401 error\nclient.interceptors.response.use(\n  (response) => response,\n  async function (error) {\n    const cookies = new Cookies();\n    const originalRequest = error.config;\n    const refresh = cookies.get('refresh');\n    //If token is expired and exist refresh is saved on cookies i can try renew access\n    if (error.response?.status === 401 && !originalRequest._retry && refresh) {\n      originalRequest._retry = true;\n      const res = await axios.post('api/token/refresh/', { refresh });\n      const { access } = res.data;\n\n      if (access) {\n        cookies.set('access', access, { path: '/' });\n      } else {\n        //Refresh is invalid. TODO redirect login\n        cookies.remove('access');\n        cookies.remove('refresh');\n      }\n      return client(originalRequest);\n    }\n    return Promise.reject(error);\n  },\n);\n\nconst handleError = async (error) => {\n  return Promise.reject(error);\n};\n\nconst handleSuccess = (response: IResponse) => {\n  return response;\n};\n\nconst request = async (options: any): Promise<IResponse> => {\n  return client(options).then(handleSuccess).catch(handleError);\n};\n\nconst post = async (url: string, data: {}): Promise<IResponse> => {\n  return request({ url: `${url}/`, data, method: 'POST' });\n};\n\nconst get = async (url: string): Promise<IResponse> => {\n  return request({ url, method: 'GET' });\n};\n\nconst remove = async (url: string, id: number): Promise<IResponse> => {\n  return request({ url: `${url}/${id}/`, method: 'DELETE' });\n};\nconst put = async (url: string, data: {}, id: number): Promise<IResponse> => {\n  return request({ url: `${url}/${id}/`, data, method: 'PUT' });\n};\nconst patch = async (url: string, data: {}, id: number): Promise<IResponse> => {\n  return request({ url: `${url}/${id}/`, data, method: 'PATCH' });\n};\n\nexport { post, request as send, client, get, put, remove, patch };\n"]},"metadata":{},"sourceType":"module"}